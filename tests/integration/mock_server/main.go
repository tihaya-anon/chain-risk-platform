package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

// 1. Real API fixtures (generated by fixture-gen tool)
// 2. Generated mock data (fallback when fixtures not available)

var (
	port        = flag.Int("port", 8545, "Port to listen on")
	fixturesDir = flag.String("fixtures", "../fixtures/ethereum", "Path to fixtures directory")
	fallback    = flag.Bool("fallback", true, "Fall back to generated data if fixture not found")

	// For fallback generated data
	startBlock = flag.Uint64("start-block", 1000, "Starting block number for generated data")
	numBlocks  = flag.Int("num-blocks", 10, "Number of blocks to simulate for generated data")
)

// FixtureStore holds loaded fixtures in memory
type FixtureStore struct {
	mu           sync.RWMutex
	blocks       map[uint64]*BlockFixture
	addresses    map[string]*AddressFixture
	internalTxs  map[string]json.RawMessage
	manifest     *Manifest
	latestBlock  uint64
	fixturesDir  string
	fallbackMode bool
}

// Manifest from fixture-gen
type Manifest struct {
	Version     string            `json:"version"`
	GeneratedAt string            `json:"generatedAt"`
	Network     string            `json:"network"`
	APISource   string            `json:"apiSource"`
	Blocks      []BlockManifest   `json:"blocks,omitempty"`
	Addresses   []AddressManifest `json:"addresses,omitempty"`
}

type BlockManifest struct {
	Number      uint64 `json:"number"`
	Hash        string `json:"hash"`
	TxCount     int    `json:"txCount"`
	Timestamp   string `json:"timestamp"`
	FixtureFile string `json:"fixtureFile"`
}

type AddressManifest struct {
	Address     string `json:"address"`
	StartBlock  uint64 `json:"startBlock"`
	EndBlock    uint64 `json:"endBlock"`
	TxCount     int    `json:"txCount"`
	FixtureFile string `json:"fixtureFile"`
}

// BlockFixture from fixture-gen
type BlockFixture struct {
	Network       string                     `json:"network"`
	BlockNumber   uint64                     `json:"blockNumber"`
	FetchedAt     string                     `json:"fetchedAt"`
	BlockResponse json.RawMessage            `json:"blockResponse"`
	InternalTxs   map[string]json.RawMessage `json:"internalTxs,omitempty"`
}

// AddressFixture from fixture-gen
type AddressFixture struct {
	Network        string          `json:"network"`
	Address        string          `json:"address"`
	StartBlock     uint64          `json:"startBlock"`
	EndBlock       uint64          `json:"endBlock"`
	FetchedAt      string          `json:"fetchedAt"`
	TxListResponse json.RawMessage `json:"txListResponse"`
}

var store *FixtureStore

func main() {
	flag.Parse()

	store = &FixtureStore{
		blocks:       make(map[uint64]*BlockFixture),
		addresses:    make(map[string]*AddressFixture),
		internalTxs:  make(map[string]json.RawMessage),
		fixturesDir:  *fixturesDir,
		fallbackMode: *fallback,
	}

	// Try to load fixtures
	if err := store.LoadFixtures(); err != nil {
		log.Printf("Warning: Failed to load fixtures: %v", err)
		if !*fallback {
			log.Fatal("Fixtures required but not available. Use -fallback=true to use generated data.")
		}
		log.Printf("Using fallback generated data mode")
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/api", handleAPI)
	mux.HandleFunc("/health", handleHealth)
	mux.HandleFunc("/status", handleStatus)

	addr := fmt.Sprintf(":%d", *port)
	log.Printf("Starting Mock Etherscan Server on %s", addr)
	log.Printf("Fixtures directory: %s", *fixturesDir)
	if store.manifest != nil {
		log.Printf("Loaded %d blocks, %d addresses from fixtures",
			len(store.manifest.Blocks), len(store.manifest.Addresses))
	}

	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatalf("Server failed: %v", err)
	}
}

// LoadFixtures loads all fixtures from disk
func (s *FixtureStore) LoadFixtures() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	// Load manifest
	manifestPath := filepath.Join(s.fixturesDir, "manifest.json")
	data, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("read manifest: %w", err)
	}

	var manifest Manifest
	if err := json.Unmarshal(data, &manifest); err != nil {
		return fmt.Errorf("parse manifest: %w", err)
	}
	s.manifest = &manifest

	// Load block fixtures
	for _, bm := range manifest.Blocks {
		blockPath := filepath.Join(s.fixturesDir, bm.FixtureFile)
		data, err := os.ReadFile(blockPath)
		if err != nil {
			log.Printf("Warning: Failed to load block %d: %v", bm.Number, err)
			continue
		}

		var fixture BlockFixture
		if err := json.Unmarshal(data, &fixture); err != nil {
			log.Printf("Warning: Failed to parse block %d: %v", bm.Number, err)
			continue
		}

		s.blocks[bm.Number] = &fixture

		// Index internal transactions
		for txHash, internalTx := range fixture.InternalTxs {
			s.internalTxs[txHash] = internalTx
		}

		// Track latest block
		if bm.Number > s.latestBlock {
			s.latestBlock = bm.Number
		}
	}

	// Load address fixtures
	for _, am := range manifest.Addresses {
		addrPath := filepath.Join(s.fixturesDir, am.FixtureFile)
		data, err := os.ReadFile(addrPath)
		if err != nil {
			log.Printf("Warning: Failed to load address %s: %v", am.Address, err)
			continue
		}

		var fixture AddressFixture
		if err := json.Unmarshal(data, &fixture); err != nil {
			log.Printf("Warning: Failed to parse address %s: %v", am.Address, err)
			continue
		}

		key := fmt.Sprintf("%s_%d_%d", am.Address, am.StartBlock, am.EndBlock)
		s.addresses[key] = &fixture
	}

	return nil
}

func handleAPI(w http.ResponseWriter, r *http.Request) {
	module := r.URL.Query().Get("module")
	action := r.URL.Query().Get("action")

	log.Printf("Request: module=%s action=%s", module, action)

	w.Header().Set("Content-Type", "application/json")

	switch {
	case module == "proxy" && action == "eth_blockNumber":
		handleGetLatestBlockNumber(w, r)
	case module == "proxy" && action == "eth_getBlockByNumber":
		handleGetBlockByNumber(w, r)
	case module == "account" && action == "txlistinternal":
		handleGetInternalTransactions(w, r)
	case module == "account" && action == "txlist":
		handleGetAddressTransactions(w, r)
	default:
		http.Error(w, `{"status":"0","message":"Unknown action"}`, http.StatusBadRequest)
	}
}

func handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}

func handleStatus(w http.ResponseWriter, r *http.Request) {
	store.mu.RLock()
	defer store.mu.RUnlock()

	status := map[string]interface{}{
		"fixturesDir":  store.fixturesDir,
		"fallbackMode": store.fallbackMode,
		"blocksLoaded": len(store.blocks),
		"latestBlock":  store.latestBlock,
	}
	if store.manifest != nil {
		status["manifestVersion"] = store.manifest.Version
		status["network"] = store.manifest.Network
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(status)
}

func handleGetLatestBlockNumber(w http.ResponseWriter, r *http.Request) {

	store.mu.RLock()
	latestBlock := store.latestBlock
	store.mu.RUnlock()

	if latestBlock == 0 && store.fallbackMode {
		latestBlock = *startBlock + uint64(*numBlocks) - 1
	}

	response := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"result":  fmt.Sprintf("0x%x", latestBlock),
	}
	json.NewEncoder(w).Encode(response)
}

func handleGetBlockByNumber(w http.ResponseWriter, r *http.Request) {
	tag := r.URL.Query().Get("tag")
	blockNum, err := strconv.ParseUint(strings.TrimPrefix(tag, "0x"), 16, 64)
	if err != nil {
		http.Error(w, `{"error":"Invalid block number"}`, http.StatusBadRequest)
		return
	}

	store.mu.RLock()
	fixture, exists := store.blocks[blockNum]
	store.mu.RUnlock()

	if exists {
		// Return fixture data
		w.Write(fixture.BlockResponse)
		return
	}

	// Fallback to generated data
	if store.fallbackMode {
		if blockNum < *startBlock || blockNum >= *startBlock+uint64(*numBlocks) {
			response := map[string]interface{}{
				"jsonrpc": "2.0",
				"id":      1,
				"result":  nil,
			}
			json.NewEncoder(w).Encode(response)
			return
		}

		block := generateMockBlock(blockNum)
		response := map[string]interface{}{
			"jsonrpc": "2.0",
			"id":      1,
			"result":  block,
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	// No fixture and no fallback
	response := map[string]interface{}{
		"jsonrpc": "2.0",
		"id":      1,
		"result":  nil,
	}
	json.NewEncoder(w).Encode(response)
}

func handleGetInternalTransactions(w http.ResponseWriter, r *http.Request) {
	txHash := r.URL.Query().Get("txhash")
	store.mu.RLock()
	internalTx, exists := store.internalTxs[txHash]
	store.mu.RUnlock()

	if exists {
		w.Write(internalTx)
		return
	}

	// Return empty result
	response := map[string]interface{}{
		"status":  "0",
		"message": "No transactions found",
		"result":  []interface{}{},
	}
	json.NewEncoder(w).Encode(response)
}

func handleGetAddressTransactions(w http.ResponseWriter, r *http.Request) {
	address := r.URL.Query().Get("address")
	startBlockStr := r.URL.Query().Get("startblock")
	endBlockStr := r.URL.Query().Get("endblock")

	startBlk, _ := strconv.ParseUint(startBlockStr, 10, 64)
	endBlk, _ := strconv.ParseUint(endBlockStr, 10, 64)

	// Try to find matching fixture
	store.mu.RLock()
	key := fmt.Sprintf("%s_%d_%d", address, startBlk, endBlk)
	fixture, exists := store.addresses[key]
	store.mu.RUnlock()

	if exists {
		w.Write(fixture.TxListResponse)
		return
	}

	// Return empty result
	response := map[string]interface{}{
		"status":  "0",
		"message": "No transactions found",
		"result":  []interface{}{},
	}
	json.NewEncoder(w).Encode(response)
}

// ============== Fallback Generated Data ==============

// generateMockBlock creates a mock block with predictable test data
func generateMockBlock(blockNum uint64) map[string]interface{} {
	timestamp := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC).Add(time.Duration(blockNum-*startBlock) * 12 * time.Second)

	// Generate 2-5 transactions per block
	numTxs := int((blockNum % 4) + 2)
	transactions := make([]map[string]interface{}, numTxs)

	for i := 0; i < numTxs; i++ {
		transactions[i] = generateMockTransaction(blockNum, i)
	}

	return map[string]interface{}{
		"number":       fmt.Sprintf("0x%x", blockNum),
		"hash":         fmt.Sprintf("0x%064x", blockNum),
		"parentHash":   fmt.Sprintf("0x%064x", blockNum-1),
		"timestamp":    fmt.Sprintf("0x%x", timestamp.Unix()),
		"miner":        "0x0000000000000000000000000000000000000001",
		"gasUsed":      fmt.Sprintf("0x%x", 21000*numTxs),
		"gasLimit":     "0x1c9c380", // 30,000,000
		"transactions": transactions,
	}
}

// generateMockTransaction creates a mock transaction with predictable test data
func generateMockTransaction(blockNum uint64, txIndex int) map[string]interface{} {
	// Generate deterministic addresses based on block and tx index
	fromAddr := fmt.Sprintf("0x%040x", blockNum*100+uint64(txIndex))
	toAddr := fmt.Sprintf("0x%040x", blockNum*100+uint64(txIndex)+1)

	// Vary the value based on tx index (in wei)
	value := uint64((txIndex + 1) * 1000000000000000000) // 1-5 ETH

	// Some transactions are ERC20 transfers (have input data)
	var input string
	if txIndex%3 == 0 {
		// ERC20 transfer(address,uint256) - method ID: 0xa9059cbb
		recipientAddr := fmt.Sprintf("%064x", blockNum*100+uint64(txIndex)+2)
		amount := fmt.Sprintf("%064x", value)
		input = "0xa9059cbb" + recipientAddr + amount
		toAddr = "0xdAC17F958D2ee523a2206206994597C13D831ec7" // USDT contract
		value = 0                                             // No ETH value for ERC20 transfers
	} else {
		input = "0x"
	}

	return map[string]interface{}{
		"hash":             fmt.Sprintf("0x%064x", blockNum*1000+uint64(txIndex)),
		"blockNumber":      fmt.Sprintf("0x%x", blockNum),
		"blockHash":        fmt.Sprintf("0x%064x", blockNum),
		"transactionIndex": fmt.Sprintf("0x%x", txIndex),
		"from":             fromAddr,
		"to":               toAddr,
		"value":            fmt.Sprintf("0x%x", value),
		"gas":              "0x5208",      // 21000
		"gasPrice":         "0x4a817c800", // 20 Gwei
		"nonce":            fmt.Sprintf("0x%x", txIndex),
		"input":            input,
	}
}
